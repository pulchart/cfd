#!/usr/bin/env python3
"""
md2guide.py - Convert Markdown to AmigaGuide format

This script converts Markdown documentation to AmigaGuide hypertext format,
which is the standard help system for Amiga computers. The conversion preserves
formatting while adapting it to AmigaGuide's capabilities.

Usage: 
    md2guide.py input.md [output.guide] [options]

Features:
    - Headings (# ## ###) -> @node sections with navigation
    - Bold (**text**) -> @{b}text@{ub}
    - Italic (*text*) -> @{i}text@{ui}  
    - Code (`code`) -> @{fg shine}code@{fg text}
    - Code blocks (```) -> verbatim with @{fg highlight}
    - Links [text](url) -> @{"text" link url} or plain URL
    - Lists (- item) -> bullet points with proper indentation
    - Tables -> formatted tables with proper alignment
    - Horizontal rules (---) -> separator lines
    - Automatic table of contents and index generation
    - Text wrapping that preserves AmigaGuide formatting

The output includes:
    - Main node with hierarchical table of contents
    - Alphabetical index of all sections
    - Navigation links between sections
    - Proper AmigaGuide formatting and encoding

Author: Jaroslav Pulchart
License: LGPL v2.1
"""

import re
import sys
import os
from datetime import datetime

SCRIPT_VERSION = '1.0 (08.01.2026)'

# Constants for text formatting
DEFAULT_WRAP_WIDTH = 72
LINE_LENGTH_LIMIT = 82
SEPARATOR_LINE_WIDTH = 60
NAV_SEPARATOR_WIDTH = 40

# AmigaGuide command constants
AG_BOLD_START = '@{b}'
AG_BOLD_END = '@{ub}'
AG_ITALIC_START = '@{i}'
AG_ITALIC_END = '@{ui}'
AG_UNDERLINE_START = '@{u}'
AG_UNDERLINE_END = '@{uu}'
AG_FG_SHINE = '@{fg shine}'         # Bright color for inline code
AG_FG_TEXT = '@{fg text}'           # Return to normal color
AG_FG_HIGHLIGHT = '@{fg highlight}' # Background highlight color

# Pattern lists for formatting tag recognition during text wrapping
AG_OPENING_TAGS = ['b}', 'i}', 'u}', 'fg shine}', 'fg highlight}']
AG_CLOSING_TAGS = [AG_BOLD_END, AG_ITALIC_END, AG_UNDERLINE_END, AG_FG_TEXT]
AG_CLOSING_TAG_PREFIXES = [AG_BOLD_END, AG_ITALIC_END, AG_UNDERLINE_END, AG_FG_TEXT]

# AmigaGuide document structure constants
AG_NODE_START = '@node'
AG_NODE_END = '@endnode'
AG_DATABASE = '@database'
AG_HELP = '@help'
AG_INDEX = '@index'
AG_FONT = '@font topaz.font 8'
AG_VERSION = '@$VER:'
AG_AUTHOR = f'@author "Generated by md2guide.py v{SCRIPT_VERSION}"'
AG_COPYRIGHT = '@(c) "See LICENSE"'

# Node and section names
MAIN_NODE = 'Main'
INDEX_NODE = 'Index'
TABLE_OF_CONTENTS = 'Table of Contents'

# Compiled regex patterns for better performance
HEADING_PATTERN = re.compile(r'^(#{1,6})\s+(.+)$')
BULLET_LIST_PATTERN = re.compile(r'^(\s*)([-*+])\s+(.+)$')
NUMBERED_LIST_PATTERN = re.compile(r'^(\s*)(\d+)\.\s+(.+)$')
HORIZONTAL_RULE_PATTERN = re.compile(r'^-{3,}$|^\*{3,}$|^_{3,}$')
NODE_CLEAN_PATTERN = re.compile(r'[^a-zA-Z0-9_]')


# ==============================================================================
# TEXT PROCESSING AND ESCAPING FUNCTIONS
# ==============================================================================

def escape_amigaguide(text):
    """
    Escape special AmigaGuide characters and convert Unicode to ASCII.
    
    AmigaGuide uses '@' as an escape character, so literal '@' must be doubled.
    Also converts common Unicode characters to their ASCII equivalents since
    AmigaGuide typically uses ISO-8859-1 encoding.
    
    Args:
        text (str): Input text that may contain special characters
        
    Returns:
        str: Text safe for use in AmigaGuide documents
    """
    # @ needs to be escaped as @@
    text = text.replace('@', '@@')
    # Replace common Unicode characters with ASCII equivalents
    replacements = {
        '→': '->',
        '←': '<-',
        '↔': '<->',
        '•': '*',
        '–': '-',
        '—': '--',
        '"': '"',
        '"': '"',
        ''': "'",
        ''': "'",
        '…': '...',
        '©': '(c)',
        '®': '(R)',
        '™': '(TM)',
        '×': 'x',
        '÷': '/',
        '≤': '<=',
        '≥': '>=',
        '≠': '!=',
        '±': '+/-',
        '✓': '[x]',
        '✗': '[ ]',
        '✔': '[x]',
        '✘': '[ ]',
        '☐': '[ ]',
        '☑': '[x]',
        '★': '*',
        '☆': '*',
        '●': '*',
        '○': 'o',
        '■': '#',
        '□': '[ ]',
        '▪': '-',
        '▫': '-',
    }
    for unicode_char, ascii_equiv in replacements.items():
        text = text.replace(unicode_char, ascii_equiv)
    # Remove any remaining non-ASCII characters
    text = text.encode('ascii', 'replace').decode('ascii')
    return text


def convert_markdown_link(text, url):
    """
    Convert Markdown link syntax to AmigaGuide link format.
    
    Handles three types of links:
    1. Internal .md links -> converted to .guide file references
    2. Anchor links (#section) -> converted to node references
    3. External URLs -> displayed as text with URL in parentheses
    
    Args:
        text (str): The display text for the link
        url (str): The URL or reference target
        
    Returns:
        str: AmigaGuide formatted link or plain text
    """
    # Internal .md link -> link to .guide file
    if url.endswith('.md'):
        # Get just the filename, replace .md with .guide
        guide_file = os.path.basename(url)[:-3] + '.guide'
        # Also update link text if it contains .md
        display_text = text.replace('.md', '.guide')
        return f'@{{"  {display_text}  " link "{guide_file}/Main"}}'
    # Anchor link
    elif url.startswith('#'):
        node = url[1:].replace('-', '_')
        return f'@{{"{text}" link {node}}}'
    # External URL -> just show text and URL
    else:
        return f'{text} ({url})'


def convert_inline(line, in_code_block=False):
    """
    Convert inline Markdown formatting to AmigaGuide equivalents.
    
    Processes bold, italic, and inline code formatting while preserving
    AmigaGuide formatting commands. When inside a code block, only
    escapes special characters without applying formatting.
    
    Conversion rules:
    - **bold** or __bold__ -> @{b}bold@{ub}
    - *italic* or _italic_ -> @{i}italic@{ui}
    - `code` -> @{fg shine}code@{fg text}
    - [text](url) -> @{"text" link url} or plain text
    
    Args:
        line (str): Text line to process
        in_code_block (bool): If True, only escape without formatting
        
    Returns:
        str: Text with AmigaGuide formatting applied
    """
    if in_code_block:
        return escape_amigaguide(line)
    
    # Replace Unicode characters first
    line = escape_amigaguide(line)
    # Note: escape_amigaguide already handles @ -> @@
    
    # Bold: **text** or __text__
    line = re.sub(r'\*\*([^*]+)\*\*', rf'{AG_BOLD_START}\1{AG_BOLD_END}', line)
    line = re.sub(r'__([^_]+)__', rf'{AG_BOLD_START}\1{AG_BOLD_END}', line)
    
    # Italic: *text* or _text_ (but not inside words)
    line = re.sub(r'(?<!\w)\*([^*]+)\*(?!\w)', rf'{AG_ITALIC_START}\1{AG_ITALIC_END}', line)
    line = re.sub(r'(?<!\w)_([^_]+)_(?!\w)', rf'{AG_ITALIC_START}\1{AG_ITALIC_END}', line)
    
    # Inline code: `code` - use fg shine for visibility
    line = re.sub(r'`([^`]+)`', rf'{AG_FG_SHINE}\1{AG_FG_TEXT}', line)
    
    # Links: [text](url)
    line = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', lambda m: convert_markdown_link(m.group(1), m.group(2)), line)
    
    return line


# ==============================================================================
# DOCUMENT STRUCTURE ANALYSIS
# ==============================================================================

def extract_nodes(lines):
    """
    Analyze Markdown headings to build document structure for navigation.
    
    Scans through all lines to find headings and creates a list of nodes
    that will be used to generate the table of contents, index, and 
    navigation links between sections.
    
    Args:
        lines (list): List of all lines in the Markdown document
        
    Returns:
        list: Tuples of (level, title, node_name) for each heading found
    """
    nodes = []
    for line in lines:
        match = HEADING_PATTERN.match(line)
        if match:
            level = len(match.group(1))
            title = match.group(2)
            node_name = NODE_CLEAN_PATTERN.sub('_', title)
            nodes.append((level, title, node_name))
    return nodes


# ==============================================================================
# TABLE PROCESSING AND FORMATTING
# ==============================================================================

def calculate_display_width(text):
    """
    Calculate the actual display width of text after removing AmigaGuide formatting.
    
    AmigaGuide formatting tags like @{b} don't take up visual space, so we need
    to calculate how wide the text will actually appear to users.
    
    Args:
        text (str): Text that may contain AmigaGuide formatting tags
        
    Returns:
        int: Actual display width in characters
    """
    # Remove AmigaGuide formatting to get actual display width
    clean_text = re.sub(r'@\{[^}]+\}', '', text)
    return len(clean_text)


def is_separator_row(cells):
    """Check if a table row is a separator row (contains only - and :)"""
    return all(c.replace('-', '').replace(':', '') == '' for c in cells)


def parse_table_cells(line):
    """Parse a table line into cells, removing leading/trailing pipes"""
    return [c.strip() for c in line.strip('|').split('|')]


def format_simple_table(table_lines):
    """Simple table format for very wide tables"""
    result = ['', '--- Table ---', '']
    
    # Parse and format rows with minimal processing
    for line in table_lines:
        if '|' in line:
            cells = parse_table_cells(line)
            # Skip separator rows
            if not is_separator_row(cells):
                formatted_cells = [convert_inline(escape_amigaguide(cell)) for cell in cells]
                result.append('  ' + ' | '.join(formatted_cells))
    
    result.append('')
    return result


def format_table(table_lines):
    """Convert markdown table to formatted AmigaGuide table"""
    if not table_lines:
        return []
    
    # Parse table
    rows = []
    for line in table_lines:
        cells = [escape_amigaguide(cell) for cell in parse_table_cells(line)]
        rows.append(cells)
    
    if len(rows) < 2:
        return table_lines  # Not a valid table
    
    # Skip separator row (second row with ---)
    header = rows[0]
    data_rows = [r for r in rows[1:] if not is_separator_row(r)]
    
    # Process all content and calculate actual display widths
    num_cols = len(header)
    processed_data = []
    col_widths = [0] * num_cols
    max_cell_width = (LINE_LENGTH_LIMIT - 6) // num_cols  # Reserve space for spacing and padding
    
    # Process header
    header_formatted = []
    for i, cell in enumerate(header):
        formatted_cell = cell  # Headers don't get inline formatting
        header_formatted.append(formatted_cell)
        col_widths[i] = max(col_widths[i], len(formatted_cell))
    
    # Process data rows with wrapping support
    for row in data_rows:
        row_formatted = []
        row_wrapped = []
        max_lines = 1
        
        for i in range(num_cols):
            cell_content = row[i] if i < len(row) else ''
            formatted_cell = convert_inline(cell_content)
            
            # Check if cell needs wrapping
            display_width = calculate_display_width(formatted_cell)
            if display_width > max_cell_width:
                # Wrap the cell content
                wrapped_lines = wrap_amigaguide_text(formatted_cell, max_cell_width)
                row_wrapped.append(wrapped_lines)
                max_lines = max(max_lines, len(wrapped_lines))
                # Use the longest wrapped line for width calculation
                max_line_width = max(calculate_display_width(line) for line in wrapped_lines)
                col_widths[i] = max(col_widths[i], max_line_width)
            else:
                row_wrapped.append([formatted_cell])
                col_widths[i] = max(col_widths[i], display_width)
        
        processed_data.append((row_wrapped, max_lines))
    
    # Check if total table width would exceed limits even with wrapping
    total_width = sum(col_widths) + (num_cols - 1) * 2 + 4  # 2 spaces between cols, 4 for padding
    if total_width > LINE_LENGTH_LIMIT:
        # Fall back to simpler format for very wide tables
        return format_simple_table(table_lines)
    
    # Build formatted table
    result = ['']
    
    # Header row with bold formatting
    header_parts = ['  ']
    for i, cell in enumerate(header_formatted):
        # Create bold header and pad to column width
        bold_cell = create_amigaguide_format(cell, AG_BOLD_START, AG_BOLD_END)
        # Pad based on display width, not string length
        padding_needed = col_widths[i] - len(cell)
        padded_cell = bold_cell + (' ' * padding_needed)
        header_parts.append(padded_cell + '  ')
    result.append(''.join(header_parts))
    
    # Separator line using calculated widths
    sep_parts = ['  ']
    for i in range(num_cols):
        sep_parts.append('-' * col_widths[i] + '  ')
    result.append(''.join(sep_parts))
    
    # Data rows with wrapping support
    for row_wrapped, max_lines in processed_data:
        for line_idx in range(max_lines):
            row_parts = ['  ']
            for col_idx in range(num_cols):
                wrapped_lines = row_wrapped[col_idx]
                if line_idx < len(wrapped_lines):
                    cell_content = wrapped_lines[line_idx]
                else:
                    cell_content = ''  # Empty for lines beyond this cell's content
                
                # Pad based on display width
                display_width = calculate_display_width(cell_content)
                padding_needed = col_widths[col_idx] - display_width
                padded_cell = cell_content + (' ' * padding_needed)
                row_parts.append(padded_cell + '  ')
            result.append(''.join(row_parts))
    
    result.append('')
    return result


def format_simple_table(table_lines):
    """Simple table format for very wide tables"""
    result = ['', '--- Table ---']
    for line in table_lines:
        if '|' in line and not line.strip().startswith('|-'):
            cells = [c.strip() for c in line.strip('|').split('|')]
            for i, cell in enumerate(cells):
                if cell:  # Skip empty cells
                    converted_cell = convert_inline(cell)
                    result.append(f'  {i+1}. {converted_cell}')
            result.append('')
    result.append('--- End Table ---')
    result.append('')
    return result


# ==============================================================================
# TEXT WRAPPING AND LINE PROCESSING
# ==============================================================================

def find_paired_fg_blocks(text):
    """Find and extract paired @{fg ...}...@{fg ...} blocks"""
    paired_blocks = []
    processed_text = ''
    pos = 0
    
    while pos < len(text):
        # Look for @{fg shine} or @{fg highlight} etc.
        fg_start_match = re.search(r'@\{fg\s+\w+\}', text[pos:])
        if fg_start_match:
            # Add text before the match
            processed_text += text[pos:pos + fg_start_match.start()]
            
            # Find the closing @{fg text}
            start_pos = pos + fg_start_match.start()
            end_search_pos = pos + fg_start_match.end()
            fg_end_match = re.search(r'@\{fg\s+\w+\}', text[end_search_pos:])
            
            if fg_end_match:
                # Found complete paired block
                end_pos = end_search_pos + fg_end_match.end()
                paired_block = text[start_pos:end_pos]
                placeholder = f"__PAIRED_{len(paired_blocks)}__"
                paired_blocks.append(paired_block)
                processed_text += placeholder
                pos = end_pos
            else:
                # No closing tag found, treat as single tag
                processed_text += text[start_pos:pos + fg_start_match.end()]
                pos += fg_start_match.end()
        else:
            # No more fg tags, add remaining text
            processed_text += text[pos:]
            break
    
    return processed_text, paired_blocks


def tokenize_text_with_formatting(text, paired_blocks):
    """Split text into tokens while preserving AmigaGuide formatting"""
    tokens = []
    i = 0
    current_token = ''
    
    while i < len(text):
        if text[i:].startswith('__PAIRED_'):
            # Handle paired block placeholder
            if current_token.strip():
                tokens.append(current_token.strip())
                current_token = ''
            
            # Extract the paired block
            end_placeholder = text.find('__', i + 2) + 2
            placeholder = text[i:end_placeholder]
            block_num = int(placeholder.split('_')[3])
            tokens.append(paired_blocks[block_num])
            i = end_placeholder
            continue
            
        elif text[i] == '@' and i + 1 < len(text) and text[i + 1] == '{':
            # Handle single AmigaGuide formatting
            if current_token.strip():
                tokens.append(current_token.strip())
                current_token = ''
            
            # Find the complete @{...} block
            brace_count = 0
            amigaguide_token = ''
            while i < len(text):
                amigaguide_token += text[i]
                if text[i] == '{':
                    brace_count += 1
                elif text[i] == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        break
                i += 1
            
            tokens.append(amigaguide_token)
            
        elif text[i] == ' ':
            if current_token.strip():
                tokens.append(current_token.strip())
                current_token = ''
        else:
            current_token += text[i]
        
        i += 1
    
    if current_token.strip():
        tokens.append(current_token.strip())
    
    return tokens


def should_add_space_before_token(current_line, token):
    """Determine if a space should be added before the current token"""
    if not current_line:
        return False
    
    # Check if previous token is an opening format tag (like @{b})
    prev_is_opening = (current_line.endswith('}') and 
                      any('@{' + tag in current_line[-10:] for tag in AG_OPENING_TAGS) and
                      not any(current_line.endswith(end) for end in AG_CLOSING_TAGS))
    
    # Check if current token is a closing format tag (like @{ub})
    curr_is_closing = token.startswith('@{') and any(token.startswith(tag) for tag in AG_CLOSING_TAG_PREFIXES)
    
    # Don't add space if previous is opening or current is closing
    return not (prev_is_opening or curr_is_closing)


def wrap_tokens_to_lines(tokens, width):
    """Wrap tokens into lines respecting width limit"""
    lines_out = []
    cur_line = ''
    
    for token in tokens:
        # Determine spacing and test line length
        space_needed = should_add_space_before_token(cur_line, token)
        test_line = cur_line + (' ' if space_needed else '') + token
        test_display_width = calculate_display_width(test_line)
        
        if test_display_width > width and cur_line:
            lines_out.append(cur_line)
            cur_line = token
        else:
            cur_line = test_line
    
    if cur_line:
        lines_out.append(cur_line)
    
    return lines_out if lines_out else ['']


def wrap_amigaguide_text(text, width=DEFAULT_WRAP_WIDTH):
    """
    Wrap text to specified width while preserving AmigaGuide formatting blocks.
    
    This is a critical function that ensures text fits within line limits
    without breaking AmigaGuide formatting commands. It uses a multi-step
    process to safely wrap text:
    
    1. Extract paired formatting blocks (like @{fg shine}...@{fg text})
    2. Tokenize the remaining text while preserving single format tags
    3. Reassemble tokens into lines that fit within the width limit
    
    Args:
        text (str): Text to wrap, may contain AmigaGuide formatting
        width (int): Maximum line width in characters
        
    Returns:
        list: List of wrapped lines, preserving all formatting
    """
    if calculate_display_width(text) <= width:
        return [text]
    
    # Step 1: Extract paired formatting blocks (like @{fg shine}...@{fg text})
    processed_text, paired_blocks = find_paired_fg_blocks(text)
    
    # Step 2: Tokenize text while preserving formatting
    tokens = tokenize_text_with_formatting(processed_text, paired_blocks)
    
    # Step 3: Wrap tokens into lines
    return wrap_tokens_to_lines(tokens, width)


def process_list_item(line, current_content):
    """
    Process both bullet and numbered list items with proper indentation.
    
    Recognizes Markdown list syntax and converts it to AmigaGuide format
    with appropriate indentation and wrapping. Supports nested lists by
    calculating indentation levels.
    
    Supported formats:
    - Bullet lists: *, -, +
    - Numbered lists: 1., 2., etc.
    - Nested lists with proper indentation
    
    Args:
        line (str): Line that might be a list item
        current_content (list): Output list to append formatted items to
        
    Returns:
        bool: True if line was processed as a list item, False otherwise
    """
    # Try bullet list first: * - +
    match = BULLET_LIST_PATTERN.match(line)
    if match:
        indent, marker, item = match.groups()
        indent_level = len(indent) // 2
        output_indent = '  ' * (indent_level + 1)
        list_lines = format_list_item(item, output_indent, '*', 1)
        current_content.extend(list_lines)
        return True
    
    # Try numbered list: 1. 2. etc.
    match = NUMBERED_LIST_PATTERN.match(line)
    if match:
        indent, num, item = match.groups()
        indent_level = len(indent) // 2
        output_indent = '  ' * (indent_level + 1)
        list_lines = format_list_item(item, output_indent, f'{num}.', len(num) + 1)
        current_content.extend(list_lines)
        return True
    
    return False


def process_markdown_line(line, current_content):
    """Process various markdown line types. Returns True if handled, False otherwise."""
    
    # Horizontal rule
    if HORIZONTAL_RULE_PATTERN.match(line):
        separator = '=' * SEPARATOR_LINE_WIDTH
        current_content.extend(['', separator, ''])
        return True

    # Blockquote (> prefix)
    if line.startswith('>'):
        quote_text = line.lstrip('>').strip()
        current_content.append(f'    {AG_ITALIC_START}"{convert_inline(quote_text)}"{AG_ITALIC_END}')
        return True

    # List items (both bullet and numbered)
    if process_list_item(line, current_content):
        return True
    
    return False


def format_list_item(item_text, output_indent, marker, marker_length):
    """Format and wrap a list item with proper indentation"""
    converted_item = convert_inline(item_text)
    first_line = f'{output_indent}{marker} {converted_item}'
    
    lines = []
    if len(first_line) > LINE_LENGTH_LIMIT:
        # Wrap the item text, then add proper indentation
        # Use a more generous width calculation to avoid breaking AmigaGuide links
        available_width = LINE_LENGTH_LIMIT - len(output_indent) - marker_length - 1  # 1 for space after marker
        wrapped_lines = wrap_amigaguide_text(converted_item, available_width)
        lines.append(f'{output_indent}{marker} {wrapped_lines[0]}')
        # Add continuation lines with proper indentation
        continuation_indent = output_indent + ' ' * (marker_length + 1)  # Align with text
        for wrapped_line in wrapped_lines[1:]:
            lines.append(f'{continuation_indent}{wrapped_line}')
    else:
        lines.append(first_line)
    
    return lines


def create_amigaguide_format(content, start_tag, end_tag):
    """Helper to create AmigaGuide formatted content"""
    return f'{start_tag}{content}{end_tag}'


def create_amigaguide_link(text, node):
    """Helper to create AmigaGuide link"""
    return f'@{{"{text}" link {node}}}'


def generate_document_header(title, version, date, ver_title=None):
    """Generate AmigaGuide document header"""
    # Use ver_title for @$VER line if provided, otherwise use title
    ver_name = ver_title if ver_title else title
    return [
        f'{AG_DATABASE} "{title}"',
        f'{AG_VERSION} {ver_name} {version} ({date})',
        AG_AUTHOR,
        AG_COPYRIGHT,
        AG_FONT,
        f'{AG_HELP} {MAIN_NODE}',
        f'{AG_INDEX} {INDEX_NODE}',
        ''
    ]


def generate_table_of_contents(title, nodes):
    """Generate main table of contents node"""
    toc = [
        f'{AG_NODE_START} {MAIN_NODE} "{TABLE_OF_CONTENTS}"',
        '',
        f'{AG_BOLD_START}{title}{AG_BOLD_END}',
        ''
    ]
    
    # Generate hierarchical TOC from H2 and H3 headings
    current_h2 = None
    for level, heading, node_name in nodes:
        if level == 2:
            toc.append(f'    @{{"{heading}" link {node_name}}}')
            current_h2 = node_name
        elif level == 3 and current_h2:
            toc.append(f'        @{{"{heading}" link {node_name}}}')
    
    toc.extend(['', AG_NODE_END, ''])
    return toc


def generate_index_node(nodes):
    """Generate alphabetical index node"""
    index = [
        f'{AG_NODE_START} {INDEX_NODE} "{INDEX_NODE}"',
        f'{AG_BOLD_START}{INDEX_NODE}{AG_BOLD_END}',
        ''
    ]
    
    # Sort nodes alphabetically and group by first letter
    sorted_nodes = sorted([(h, n) for l, h, n in nodes if l <= 3], key=lambda x: x[0].lower())
    current_letter = ''
    
    for heading, node_name in sorted_nodes:
        first_letter = heading[0].upper() if heading else ''
        if first_letter != current_letter and first_letter.isalpha():
            current_letter = first_letter
            index.append(f'{AG_BOLD_START}{current_letter}{AG_BOLD_END}')
        index.append(f'  @{{"{heading}" link {node_name}}}')
    
    index.extend(['', AG_NODE_END, ''])
    return index


# AmigaGuide command prefixes that shouldn't be wrapped
AG_COMMAND_PREFIXES = [AG_NODE_START, AG_NODE_END, AG_DATABASE]


def should_skip_wrapping(line, converted):
    """Check if a line should skip text wrapping"""
    return (line.startswith('|') or  # Table line
            BULLET_LIST_PATTERN.match(line) or  # List item
            NUMBERED_LIST_PATTERN.match(line) or  # Numbered list
            line.lstrip().startswith('>') or  # Blockquote
            any(converted.lstrip().startswith(cmd) for cmd in AG_COMMAND_PREFIXES))  # AmigaGuide commands


def md2guide(md_content, title=None, version="1.0", date=None, ver_title=None):
    """
    Convert Markdown content to AmigaGuide hypertext format.
    
    This is the main conversion function that orchestrates the entire process:
    
    1. Parse the Markdown to extract document structure (headings)
    2. Generate document header with metadata
    3. Create table of contents and alphabetical index
    4. Process each line of content:
       - Code blocks: preserve formatting with @{fg highlight}
       - Tables: format with proper alignment
       - Lists: handle bullet and numbered with indentation
       - Headings: create @node sections with navigation
       - Regular text: apply inline formatting and wrapping
    5. Add navigation links between sections
    6. Clean up empty lines
    
    Args:
        md_content (str): Complete Markdown document as string
        title (str, optional): Document title, extracted from first H1 if None
        version (str): Version string for @$VER: line
        date (str, optional): Date string, current date if None
        
    Returns:
        str: Complete AmigaGuide document ready for saving
    """
    
    if date is None:
        date = datetime.now().strftime("%d.%m.%Y")
    
    lines = md_content.split('\n')
    nodes = extract_nodes(lines)
    
    # Extract title from first H1 if not provided
    if title is None:
        for level, heading, _ in nodes:
            if level == 1:
                title = heading
                break
        if title is None:
            title = "Documentation"
    
    # Build output
    output = []
    
    # Add document header with metadata and navigation setup
    output.extend(generate_document_header(title, version, date, ver_title))
    
    # Add table of contents
    output.extend(generate_table_of_contents(title, nodes))
    
    # Add index
    output.extend(generate_index_node(nodes))    

    # Build node index for navigation
    node_list = ['Main']  # Main is first
    for level, heading, node_name in nodes:
        if level <= 3:  # Only H1-H3 create nodes
            node_list.append(node_name)
    
    def get_nav_links(current_idx):
        """
        Generate Previous/Contents/Next navigation links for a node.
        
        Creates the AmigaGuide navigation bar that appears at the bottom
        of each section, allowing users to easily move between sections
        or return to the main contents.
        """
        nav = []
        nav.append('')
        nav.append('-' * NAV_SEPARATOR_WIDTH)
        links = []
        if current_idx > 0:
            prev_node = node_list[current_idx - 1]
            links.append(f'@{{"<< Prev" link {prev_node}}}')
        links.append('@{"Contents" link Main}')
        if current_idx < len(node_list) - 1:
            next_node = node_list[current_idx + 1]
            links.append(f'@{{"Next >>" link {next_node}}}')
        nav.append('  '.join(links))
        return nav
    
    # Process content into nodes
    current_node = None
    current_node_idx = 0
    current_content = []
    in_code_block = False
    in_table = False
    table_lines = []
    code_lang = None
    
    for line in lines:
        # Code block handling - ``` starts/ends code blocks
        if line.startswith('```'):
            if not in_code_block:
                in_code_block = True
                code_lang = line[3:].strip()  # Extract language (for future use)
                current_content.append('@{fg highlight}')  # Start highlighted section
            else:
                in_code_block = False
                current_content.append('@{fg text}')  # Return to normal color
            continue
        
        if in_code_block:
            current_content.append('  ' + escape_amigaguide(line))
            continue
        
        # Table handling
        is_table_line = line.strip().startswith('|') and line.strip().endswith('|')
        if is_table_line:
            if not in_table:
                in_table = True
                table_lines = []
            table_lines.append(line)
            continue
        elif in_table:
            # End of table, format and add
            in_table = False
            formatted = format_table(table_lines)
            current_content.extend(formatted)
            table_lines = []
            # Continue processing current line
        
        # Process various markdown elements
        if process_markdown_line(line, current_content):
            continue
        
        # Heading processing - creates new nodes for H1-H3, inline formatting for H4+
        match = HEADING_PATTERN.match(line)
        if match:
            level = len(match.group(1))  # Count # characters to get heading level
            heading = match.group(2)
            
            # H4+ headings become inline bold text, not separate nodes
            if level >= 4:
                heading_content = create_amigaguide_format(convert_inline(heading), AG_BOLD_START, AG_BOLD_END)
                current_content.append(heading_content)
                continue
            
            # H1-H3 headings create new @node sections
            # First, save the previous node if it exists
            if current_node:
                # Remove trailing empty lines
                while current_content and current_content[-1] == '':
                    current_content.pop()
                # Add navigation links
                current_content.extend(get_nav_links(current_node_idx))
                output.extend(current_content)
                output.append('')
                output.append('@endnode')
                output.append('')
            
            node_name = NODE_CLEAN_PATTERN.sub('_', heading)
            
            # Find index of this node
            if node_name in node_list:
                current_node_idx = node_list.index(node_name)
            
            current_node = node_name
            current_content = []
            output.append(f'@node {node_name} "{heading}"')
            
            if level == 1:
                current_content.append(create_amigaguide_format(heading, f'{AG_BOLD_START}{AG_UNDERLINE_START}', f'{AG_UNDERLINE_END}{AG_BOLD_END}'))
            elif level == 2:
                current_content.append(create_amigaguide_format(heading, AG_BOLD_START, AG_BOLD_END))
                # Add subsection links if this H2 has H3 children
                subsections = []
                found_self = False
                for l, h, n in nodes:
                    if l == 2 and n == node_name:
                        found_self = True
                        continue
                    if found_self:
                        if l == 2:  # Next H2, stop
                            break
                        if l == 3:  # H3 subsection
                            subsections.append((h, n))
                if subsections:
                    subsection_content = [create_amigaguide_format('Subsections:', AG_ITALIC_START, AG_ITALIC_END)]
                    for sub_heading, sub_node in subsections:
                        subsection_content.append(f'  {create_amigaguide_link(f"  {sub_heading}  ", sub_node)}')
                    current_content.extend(subsection_content)
            else:
                current_content.append(create_amigaguide_format(heading, AG_ITALIC_START, AG_ITALIC_END))
            # Only add empty line for headings if next line isn't empty
            continue
        
        # Regular line - wrap at specified width, never split AmigaGuide formatting blocks
        converted = convert_inline(line)
        display_width = calculate_display_width(converted)
        if display_width > DEFAULT_WRAP_WIDTH and not should_skip_wrapping(line, converted):
            wrapped_lines = wrap_amigaguide_text(converted, DEFAULT_WRAP_WIDTH)
            current_content.extend(wrapped_lines)
        else:
            current_content.append(converted)
    
    # Close last node
    if current_node:
        # Remove trailing empty lines
        while current_content and current_content[-1] == '':
            current_content.pop()
        # Add navigation links
        current_content.extend(get_nav_links(current_node_idx))
        output.extend(current_content)
        output.append('')
        output.append('@endnode')
    
    # Simple post-process: remove consecutive empty lines only
    result = []
    prev_empty = False
    
    for line in output:
        is_empty = line.strip() == ''
        if is_empty and prev_empty:
            continue  # Skip consecutive empty lines
        result.append(line)
        prev_empty = is_empty
    
    return '\n'.join(result)


def main():
    if len(sys.argv) < 2:
        print("Usage: md2guide.py input.md [output.guide] [--version X.Y] [--date DD.MM.YYYY] [--ver-title TITLE]")
        print("")
        print("Converts Markdown to AmigaGuide format.")
        print("")
        print("Options:")
        print("  --version X.Y       Set version string (default: 1.0)")
        print("  --date DD.MM.YYYY   Set date (default: today)")
        print("  --title TITLE       Set document title (default: from H1)")
        print("  --ver-title TITLE   Set title for @$VER line (default: from title)")
        sys.exit(1)
    
    input_file = sys.argv[1]
    
    # Parse optional arguments
    output_file = None
    version = "1.0"
    date = None
    title = None
    ver_title = None
    
    i = 2
    while i < len(sys.argv):
        arg = sys.argv[i]
        if arg == '--version' and i + 1 < len(sys.argv):
            version = sys.argv[i + 1]
            i += 2
        elif arg == '--date' and i + 1 < len(sys.argv):
            date = sys.argv[i + 1]
            i += 2
        elif arg == '--title' and i + 1 < len(sys.argv):
            title = sys.argv[i + 1]
            i += 2
        elif arg == '--ver-title' and i + 1 < len(sys.argv):
            ver_title = sys.argv[i + 1]
            i += 2
        elif not arg.startswith('--'):
            output_file = arg
            i += 1
        else:
            i += 1
    
    if output_file is None:
        output_file = os.path.splitext(input_file)[0] + '.guide'
    
    # Read input
    with open(input_file, 'r', encoding='utf-8') as f:
        md_content = f.read()
    
    # Convert
    guide_content = md2guide(md_content, title=title, version=version, date=date, ver_title=ver_title)
    
    # Write output
    with open(output_file, 'w', encoding='iso-8859-1') as f:
        f.write(guide_content)
    
    print(f"Converted: {input_file} -> {output_file}")


if __name__ == '__main__':
    main()

